<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Rainbow Text Preview</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Pico.css for minimal styling -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2.0.6/css/pico.min.css">
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
</head>
<body>
  <main class="container" id="app">
    <article>
      <header>
        <h1>Rainbow Text Preview</h1>
      </header>
      <label for="rainbow-textarea">Rainbow Text</label>
      <textarea id="rainbow-textarea" v-model="input" placeholder="Type here..."></textarea>
      <button @click="copyWoWEscaped" :aria-busy="copied ? 'true' : 'false'">Copy WoW Rainbow</button>
      <small v-if="copied">Copied!</small>
      <div class="rainbow-output" v-html="rainbowText"></div>
    </article>
  </main>
  <script>
    // Color utility functions
    const ColorUtils = {
      /**
       * Generate rainbow colors evenly distributed across the HSL spectrum
       * @param {number} count - Number of colors to generate
       * @returns {string[]} Array of HSL color strings
       */
      generateRainbowColors(count) {
        const colors = [];
        for (let i = 0; i < count; i++) {
          const hue = Math.round((i / count) * 360);
          colors.push(`hsl(${hue}, 85%, 60%)`);
        }
        return colors;
      },

      /**
       * Convert HSL color string to WoW-compatible hex format (RRGGBB)
       * @param {string} hslString - HSL color string like "hsl(120, 85%, 60%)"
       * @returns {string} Hex color string without # prefix
       */
      hslToHex(hslString) {
        const hslMatch = hslString.match(/hsl\(([\d.]+),\s*([\d.]+)%,\s*([\d.]+)%\)/);
        if (!hslMatch) return 'FFFFFF';

        const h = parseFloat(hslMatch[1]) / 360;
        const s = parseFloat(hslMatch[2]) / 100;
        const l = parseFloat(hslMatch[3]) / 100;

        const { r, g, b } = this.hslToRgb(h, s, l);
        return this.rgbToHex(r, g, b);
      },

      /**
       * Convert HSL values to RGB
       * @param {number} h - Hue (0-1)
       * @param {number} s - Saturation (0-1)
       * @param {number} l - Lightness (0-1)
       * @returns {object} RGB values
       */
      hslToRgb(h, s, l) {
        let r, g, b;

        if (s === 0) {
          r = g = b = l; // Achromatic (grayscale)
        } else {
          const hueToRgb = (p, q, t) => {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1/6) return p + (q - p) * 6 * t;
            if (t < 1/2) return q;
            if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
            return p;
          };

          const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          const p = 2 * l - q;
          r = hueToRgb(p, q, h + 1/3);
          g = hueToRgb(p, q, h);
          b = hueToRgb(p, q, h - 1/3);
        }

        return { r, g, b };
      },

      /**
       * Convert RGB values to hex string
       * @param {number} r - Red (0-1)
       * @param {number} g - Green (0-1)
       * @param {number} b - Blue (0-1)
       * @returns {string} Hex color string
       */
      rgbToHex(r, g, b) {
        const toHex = (component) => {
          const hex = Math.round(component * 255).toString(16);
          return hex.length === 1 ? '0' + hex : hex;
        };

        return (toHex(r) + toHex(g) + toHex(b)).toUpperCase();
      }
    };

    // Text formatting utilities
    const TextUtils = {
      /**
       * Convert text to HTML with rainbow colors
       * @param {string} text - Input text
       * @returns {string} HTML string with colored spans
       */
      toRainbowHtml(text) {
        if (!text) return '';

        const characters = [...text];
        const colors = ColorUtils.generateRainbowColors(characters.length);
        
        return characters.map((char, index) => {
          if (char === ' ') return '&nbsp;';
          if (char === '\n') return '<br>';
          return `<span style="color:${colors[index]}">${char}</span>`;
        }).join('');
      },

      /**
       * Convert text to WoW color-coded format
       * @param {string} text - Input text
       * @returns {string} WoW-formatted text with color codes
       */
      toWoWFormat(text) {
        if (!text) return '';

        const characters = [...text];
        const colors = ColorUtils.generateRainbowColors(characters.length);
        
        return characters.map((char, index) => {
          if (char === '\n') return '\n';
          const hexColor = ColorUtils.hslToHex(colors[index]);
          return `|cFF${hexColor}${char}|r`;
        }).join('');
      }
    };

    // Vue application
    const app = Vue.createApp({
      data() {
        return {
          input: '',
          copied: false,
        };
      },

      computed: {
        rainbowText() {
          return TextUtils.toRainbowHtml(this.input);
        }
      },

      methods: {
        async copyWoWEscaped() {
          if (!this.input) return;

          try {
            const wowFormattedText = TextUtils.toWoWFormat(this.input);
            await navigator.clipboard.writeText(wowFormattedText);
            this.showCopiedMessage();
          } catch (error) {
            this.handleCopyError(error);
          }
        },

        showCopiedMessage() {
          this.copied = true;
          setTimeout(() => {
            this.copied = false;
          }, 1200);
        },

        handleCopyError(error) {
          this.copied = false;
          alert(`Copy failed: ${error.message}`);
        }
      }
    });

    app.mount('#app');
  </script>
</body>
</html>